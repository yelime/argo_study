/** programmers 문제풀이
 * 
 * ==========================================
 * 체육복
 * 
 * 문제 설명
 * 체육복을 도난당해 여벌 체육복이 있는 학생이 체육복을 빌려주려고 합니다. 학생들의 번호는 체격
 * 순으로 매겨져 있어, 바로 앞번호의 학생이나 바로 뒷번호의 학생에게만 체육복을 빌려줄 수 있습니다.
 * 체육복이 없으면 수업을 들을 수 없기 때문에 체육복을 적절히 빌려 최대한 많은 학생이 체육수업을
 * 들어야 합니다.
 * 
 * 전체 학생의 수 n, 체육복을 도난당한 학생들의 번호가 담긴 배열 lost, 여벌의 체육복을 가져온 
 * 학생들의 번호가 담긴 배열 reserve가 매개변수로 주어질 때, 체육수업을 들을 수 있는 학생의 
 * 최댓값을 return 하도록 solution 함수를 작성해주세요.
 * 
 * 제한사항
 *  전체 학생의 수는 2명 이상 30명 이하입니다.
 *  체육복을 도난당한 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다.
 *  여벌의 체육복을 가져온 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다.
 *  여벌 체육복이 있는 학생만 다른 학생에게 체육복을 빌려줄 수 있습니다.
 *  여벌 체육복을 가져온 학생이 체육복을 도난당했을 수 있습니다. 이때 이 학생은 체육복을 
 *  하나만 도난당했다고 가정하며, 남은 체육복이 하나이기에 다른 학생에게는 체육복을 빌려줄 수 
 * 없습니다.
 * 
 * 입출력 예
 *  n	lost	reserve	    return
 *  5	[2, 4]	[1, 3, 5]	5
 *  5	[2, 4]	[3]	        4
 *  3	[3]	    [1] 	    2
 * ===================================
 * 
 * 이 문제는 2~30으로 학생 수가 제한 된 것은 비트 마스크를 쓰는 것을 생각해 볼 수 있다.
 * int가 32bit를 사용하므로 30까지 충분히 커버가 되며, lost와 reserve를 마스킹해서 lost와
 * reserve 양쪽에 모두 해당되는 학생을 찾기에 편리하다. 하지만 여기서는 lost의 크기를 los로
 * 받아 이를 감소하는 방식으로 참가 불가능한 학생을 찾으므로 위 방법을 쓰지는 않았다.
 * 마스킹방식을 사용하면 1<<i를 반복하며 1을 찾는 방식을 할 수 있다.
 * (마스킹을 강조하는 것이 도난당했지만, 여유분이 있으면 우선 순위가 자신인 것을 뒤늦게 발견
 * 해서 적용하지를 않았다.)
 * 
 * 이후 앞,뒤 순으로 찾아보고 만족하면 los값을 감소하고 result(아직 체육복이 없는 학생)를
 * 갱신하고, 중간에 result가 0. 즉, 모든 학생들이 체육복을 갖게 되었을 경우이므로 return
 * 해준다.
 */

class study6 {
    public int solution(int n, int[] lost, int[] reserve) {
        int answer = 0;
        int result = 0;
        int los = lost.length;
        //lost배열을 하나의 int값으로 바꾸는 작업
        for(int i=0;i<lost.length;i++){
            result+= 1<<(lost[i]-1);
        }
        //여유분을 갖고 있는 lost에게 우선적으로 체육복을 사용
        for(int i=0;i<reserve.length;i++){
            if((1<<(reserve[i]-1)&result) !=0){
                result-= 1<<(reserve[i]-1);
                los--;
                reserve[i]=0;
            }
        }
        for(int i=0;i<reserve.length;i++){
            //모든 학생이 체육복을 얻었을 경우 학생 수를 반환
            if(result==0){
                return n;
            }
            //위에서 이미 사용되었다면 continue
            if(reserve[i]==0){
                continue;
            }
            //잉여 여유분과 분실자를 매칭 시켜준다
            if(i==0&&reserve[i]==1){
                if((1<<reserve[i]&result) != 0){
                    los--;
                    result-=1<<reserve[i];
                    continue;
                }
            }
            if((1<<(reserve[i]-2)&result) != 0){
                los--;
                result-= 1<<(reserve[i]-2);
                continue;
            }
            else if((1<<reserve[i]&result) != 0){
                los--;
                result-=1<<reserve[i];
                continue;
            }
        }
        answer = n-los;
        return answer;
    }
}

/**
 * 실행 결과
 * 테스트 1 〉	통과 (0.02ms, 52.2MB)
 * 테스트 2 〉	통과 (0.04ms, 52.4MB)
 * 테스트 3 〉	통과 (0.02ms, 52.6MB)
 * 테스트 4 〉	통과 (0.02ms, 54.1MB)
 * 테스트 5 〉	통과 (0.02ms, 54.1MB)
 * 테스트 6 〉	통과 (0.03ms, 51.9MB)
 * 테스트 7 〉	통과 (0.02ms, 52.8MB)
 * 테스트 8 〉	통과 (0.03ms, 53MB)
 * 테스트 9 〉	통과 (0.02ms, 52.8MB)
 * 테스트 10 〉	통과 (0.03ms, 52.6MB)
 * 테스트 11 〉	통과 (0.03ms, 52.1MB)
 * 테스트 12 〉	통과 (0.02ms, 52.6MB)
 */