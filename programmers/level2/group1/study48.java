/** programmers 문제풀이
 * 
 * ==========================================
 * 가장 큰 수
 * 문제 설명
 * 0 또는 양의 정수가 주어졌을 때, 정수를 이어 붙여 만들 수 있는 
 * 가장 큰 수를 알아내 주세요.
 * 
 * 예를 들어, 주어진 정수가 [6, 10, 2]라면 [6102, 6210, 1062, 
 * 1026, 2610, 2106]를 만들 수 있고, 이중 가장 큰 수는 6210입니다.
 * 
 * 0 또는 양의 정수가 담긴 배열 numbers가 매개변수로 주어질 때, 
 * 순서를 재배치하여 만들 수 있는 가장 큰 수를 문자열로 바꾸어 return 
 * 하도록 solution 함수를 작성해주세요.
 * 
 * 제한 사항
 * numbers의 길이는 1 이상 100,000 이하입니다.
 * numbers의 원소는 0 이상 1,000 이하입니다.
 * 정답이 너무 클 수 있으니 문자열로 바꾸어 return 합니다.
 * 
 * 입출력 예
 * numbers	            return
 * [6, 10, 2]	        "6210"
 * [3, 30, 34, 5, 9]	"9534330"
 * ===================================
 * 
 * 가장 큰 수를 만드는 것은 가장 큰 수를 앞으로 보내는 것이 아니라 
 * 앞자리가 큰 것을 보내는 것이다. 예를 들어 998 보다 9를 우선 적으로 
 * 보내야 하고 47, 475, 474가 있을 경우 순서는 475, 47,474 순으로 앞
 * 에 보내야 한다. 또한, 999 와 99와 9는 같은 우선 순위를 가진다. 
 * 이를 위해서 999부터 100까지 역으로 찾아가면서 3자리가 같을 경우 즉,
 * 777에서는 77과 7을 동시에 처리해 줄 것이고, 10~98까지는 백의 자리와 
 * 십의 자리를 비교해서 십의 자리가 클 경우와 백의 자리가 클경우로 나누어
 * 10~98의 위치를 찾을 것이다. 위치를 찾는 방법은 만약 52의 위치를 찾아
 * 보면, 528은 백은 5, 십은 2이다.  백의 자리가 클 경우, 525 보다 작고,
 * 524보다 큰 값을 가지는 것이다. (524 < 52 < 525) 하지만 25의 경우는 
 * 십의 자리가 더 크므로 252보다 크고 253보다 작다. (252<25<253)
 * 즉, 찾고자하는 값을 x라 하면, 
 * x / 10 > x % 10 일 때, 
 * x * 10 + x / 10 - 1 <x< x * 10 + x / 10 이고,
 * x / 10 < x % 10 일 때,
 * x * 10 + x / 10 < x < x * 10 + x / 10 + 1 을 만족한다.
 * 999~100까지의 처리가 끝나면 우선순위가 가장 낮은 0과 1000이 남는데, 
 * 이는 따로 처리해 주고 1000 > 0 의 우선 순위를 가진다.
 * 
 * 그리고, 제한 사항에 원소보다 길이가 더 길어질 수 있으므로 numbers를 
 * 정렬하는 것이 아니라 0~1000까지 히스토그램을 활용해서 하는 것이 길이가 
 * 2000을 넘어갈 경우 효율적일 것이라 판단해서 사용하도록 했다.
 * 
 * 테스트의 마지막은 모든 원소가 0인 문제인데 이것을 찾으면 바로 0을 리턴
 * 해 주도록 하였다.
 * 
 */

public class study48 {
    public String solution(int[] numbers) {
        int[] nums = new int[1001];
        StringBuffer buf = new StringBuffer();
        for(int n : numbers){
            nums[n]++;
        }
        if(nums[0] ==numbers.length){
            return "0";
        }
        for(int i = 999;i>=100;i--){
            int tmp = i/10;
            
            for(int j = 0;j<nums[i];j++){
                buf.append(i);
            }
            if(tmp == i%100){
                for(int j=0;j<nums[tmp/10];j++){
                    buf.append(tmp/10);
                }
                for(int j=0;j<nums[tmp];j++){
                    buf.append(tmp);
                }
                continue;
            }
            
            if(tmp/10 == tmp%10){
                continue;
            }

            int t = tmp%10<tmp/10 ? tmp*10+tmp/10 : tmp*10+tmp/10+1;
            if(t == i){
                for(int j =0;j<nums[tmp];j++){
                    buf.append(tmp);
                }
            }
        }
        for(int i = 0; i<nums[1000];i++){
            buf.append(1000);
        }
        for(int i=0;i<nums[0];i++){
            buf.append(0);
        }
        
        return buf.toString();
    }
}
/**
 * 실행 결과
 * 테스트 1 〉	통과 (10.91ms, 67.4MB)
 * 테스트 2 〉	통과 (7.50ms, 56.7MB)
 * 테스트 3 〉	통과 (14.25ms, 60.9MB)
 * 테스트 4 〉	통과 (1.50ms, 52.9MB)
 * 테스트 5 〉	통과 (10.50ms, 57.9MB)
 * 테스트 6 〉	통과 (8.25ms, 57.3MB)
 * 테스트 7 〉	통과 (0.18ms, 52.1MB)
 * 테스트 8 〉	통과 (0.18ms, 52.6MB)
 * 테스트 9 〉	통과 (0.19ms, 52.2MB)
 * 테스트 10 〉	통과 (0.18ms, 51.7MB)
 * 테스트 11 〉	통과 (0.07ms, 52.8MB)
 */